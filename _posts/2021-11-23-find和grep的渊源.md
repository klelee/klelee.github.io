---
layout: post
title: Linux查找(下)
categories: Linux学习
description: 上一篇中具体的说了说find命令的一些简单的用法，从头到尾看起来都很简单，有人就说啦：“啊，大名鼎鼎的find命令也不过如此嘛！”那么今天的他来了——通配符与正则表达式。
keywords: Linux学习, find, grep
---





# find与grep的前世今生

## grep命令

这里先简单介绍一下grep命令，通俗的来说明grep的作用就是，查找【文件中】包含字符串`xxx`的行。

### grep命令的基本语法

```bash
grep [options] [keywords] [file PATH]
```

### grep命令的基本应用

- 实例：搜索`/home/klelee/abc`文件中含有hello的行

  ![image-20211215143930197](https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215143930197.png)

**注**：grep命令是一个很强大命令，这里只是简单的介绍，后面会写专门的章节研究grep命令的。

## find命令-通配符查找

先来看一个特殊案例，在`/home/klelee/find_grep/`目录下新建连个文件，`abc` , `abcd`文件，使用find命令检索abc字段，看看会搜到什么，let's go!

![image-20211215144052930](https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215144052930.png)

可以看到，我们以abc字段进行检索的情况下，find命令只能检索到abc文件，不能检索到其他的文件，哪怕是同样以abc开头的abcd文件。

但是find如此强大，会被这么一个小难题困住吗？当然不会。因此，find可以使用通配符进行查找，下面列出几种find使用的通配符。

| 通配符 | 描述                                        |
| ------ | ------------------------------------------- |
| *      | 匹配0个或多个【任意】内容                   |
| ？     | 匹配一个【任意】字符                        |
| [ ]    | 匹配括号中的任意【一个】字符                |
| [a-z]  | 匹配括号中指定区域的字符，如：[A-Z],[0-9]等 |
| [^]    | 表示排除括号中的字符                        |

### 基本语法

```bash
find [PATH] -name <字段和通配符>
```

### 应用实例

那么接下来我们继续去检索abc字段，不过这次我们适当的使用通配符

- 案例一：使用通配符“*”号，匹配以abc开头的文件

  ![image-20211215144152647](https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215144152647.png)

啊，在这里遇到错误啦，查百度说，查找多个文件时，需要给匹配字段加双引号哦。这里索引到两个文件。要注意的是匹配到了abc这个文件，这个时候的匹配符“*”其实相当于0个任意字符。

- 案例二：使用通配符“？”以及“[ abcde ]”号，匹配以abc开头的文件

  <img src="https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215144225906.png" alt="image-20211215144225906"  />

咦，只检索到abcd文件，却没有搜索到abc文件。这是因为？号和[]都至少要匹配一个字符哦。

- 案例三：使用find命令搜索根目录下以cd结尾的普通文件

  ![image-20211215144336996](https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215144336996.png)

以上就是find命令搭配通配符进行检索的一些知识，这些应用是很灵活的。从几个实例可以看出来，find通配符是一种匹配式检索，必须符合你输入的字段的格式，比如“*cd”，就是必须以cd结尾的文件或目录。接下来，我们对比学习grep使用正则表达式。

## grep命令-正则表达式查找

为了对比find，grep也做一个小小的实验，观察观察！在`/home/klelee/find_grep/abc` 文件中检索abc字段，看看都能检索到一些什么？

![image-20211215144511548](https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215144511548.png)

可以看到，检索到的abc的位置，什么样的都有，有行首的，有行尾的，甚至行中的都检索到了。所以概括而言，grep的检索，就是这句话里只要有检索的字段，就将这句话输出。这就是**包含查找**。

但是，对于这种包含查找，也有特殊的需求，比如我想搜“abcd【好几个d】”？？？？怎么搜，或者“a【b我也不知道有没有b】c”？？？是不是有很多问号，这就是模糊查询，这时候就用到了grep命令的“通配符了”。

正则表达式的“通配符”

| 符号  | 描述                         |
| ----- | ---------------------------- |
| ？    | 前一项是可选的，最多匹配一次 |
| *     | 匹配前一个字符0ci或多次      |
| [ ]   | 匹配括号中的任意字符         |
| [a-z] | 匹配a-z中间的任意字符        |
| [^]   | 匹配不包含字段的行           |
| ^     | 匹配开头样式                 |
| &     | 匹配结尾样式                 |

### 基本语法

```bash
grep "要匹配的字段" [文件]
```

### 应用实例

- 实例一：在abc文件中寻找abc或者abcd

  分析：什么意思呢？就是这个d可有可无呗？那根据上面的正则表达式可以看出需要使用“？”号

  ![image-20211215144655298](https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215144655298.png)

咦？怎么会没有呢？这是因为，在shell的正则表达式中是没有？这个匹配选项的，这种情况下，我们应该使用egrep

- 实例二：在abc文件中寻找abc好几个d的行

  ![image-20211215144828391](https://klelee-image.oss-cn-qingdao.aliyuncs.com/image/image-20211215144828391.png)

最难理解的就是“？”和“*”，其他的都很简单。

## 对比find和grep

1. find用来搜索文件，而grep用来搜索内容。
2. find搜索讲究的是，要按我想的来的一摸一样，grep讲究的是差不多就行，abc管他好几个d，有d就行。但是find不可以，abc是abc吗，abcd就得加通配符了。

## 结语

find到此为止了，可是grep却刚刚开始！
